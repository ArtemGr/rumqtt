var searchIndex = {};
searchIndex["rumqtt"] = {"doc":"A fast, lock free Mqtt client implementation in Rust.","items":[[4,"QoS","rumqtt","",null,null],[13,"Level0","","",0,null],[13,"Level1","","",0,null],[13,"Level2","","",0,null],[3,"MqttOptions","","",null,null],[12,"addr","","",1,null],[12,"keep_alive","","",1,null],[12,"clean_session","","",1,null],[12,"client_id","","",1,null],[12,"username","","",1,null],[12,"password","","",1,null],[12,"reconnect","","",1,null],[12,"will","","",1,null],[12,"will_qos","","",1,null],[12,"will_retain","","",1,null],[12,"pub_q_len","","",1,null],[12,"sub_q_len","","",1,null],[12,"queue_timeout","","",1,null],[12,"ca","","",1,null],[12,"verify_ca","","",1,null],[12,"client_cert","","",1,null],[3,"MqttClient","","Handles commands from Publisher and Subscriber. Saves MQTT\nstate and takes care of retransmissions.",null,null],[12,"opts","","",2,null],[12,"state","","",2,null],[12,"last_pkid","","",2,null],[12,"pub0_channel_pending","","",2,null],[12,"pub1_channel_pending","","",2,null],[12,"pub2_channel_pending","","",2,null],[12,"pub0_rx","","",2,null],[12,"pub1_rx","","",2,null],[12,"pub2_rx","","",2,null],[12,"sub_rx","","",2,null],[12,"nw_request_tx","","",2,null],[12,"nw_notification_rx","","",2,null],[12,"misc_rx","","",2,null],[12,"message_callback","","On message callback",2,null],[12,"publish_callback","","On publish callback",2,null],[12,"poll","","Poll",2,null],[3,"MqRequest","","",null,null],[12,"pub0_tx","","",3,null],[12,"pub1_tx","","",3,null],[12,"pub2_tx","","",3,null],[12,"subscribe_tx","","",3,null],[12,"misc_tx","","",3,null],[3,"Message","","",null,null],[12,"topic","","",4,null],[12,"retain","","",4,null],[12,"qos","","",4,null],[12,"payload","","",4,null],[12,"userdata","","",4,null],[4,"Error","","",null,null],[13,"ConnectionAbort","","",5,null],[13,"ConnectionRefused","","",5,null],[13,"Io","","",5,null],[13,"SendError","","",5,null],[13,"Recv","","",5,null],[13,"TryRecv","","",5,null],[13,"Timer","","",5,null],[13,"TopicName","","",5,null],[13,"TopicFilter","","",5,null],[13,"NoReconnectTry","","",5,null],[13,"MqttPacket","","",5,null],[13,"Ssl","","",5,null],[13,"PingTimeout","","",5,null],[13,"AwaitPingResp","","",5,null],[13,"InvalidPacket","","",5,null],[13,"InvalidState","","",5,null],[13,"HandshakeFailed","","",5,null],[13,"Handshake","","",5,null],[11,"fmt","","",5,null],[11,"from","","",5,{"inputs":[{"name":"error"}],"output":{"name":"error"}}],[11,"from","","",5,{"inputs":[{"name":"topicnameerror"}],"output":{"name":"error"}}],[11,"from","","",5,{"inputs":[{"name":"topicfiltererror"}],"output":{"name":"error"}}],[11,"from","","",5,{"inputs":[{"name":"senderror"}],"output":{"name":"error"}}],[11,"from","","",5,{"inputs":[{"name":"senderror"}],"output":{"name":"error"}}],[11,"from","","",5,{"inputs":[{"name":"recverror"}],"output":{"name":"error"}}],[11,"from","","",5,{"inputs":[{"name":"tryrecverror"}],"output":{"name":"error"}}],[11,"from","","",5,{"inputs":[{"name":"packeterror"}],"output":{"name":"error"}}],[11,"from","","",5,{"inputs":[{"name":"errorstack"}],"output":{"name":"error"}}],[11,"from","","",5,{"inputs":[{"name":"handshakeerror"}],"output":{"name":"error"}}],[11,"from","","",5,{"inputs":[{"name":"timererror"}],"output":{"name":"error"}}],[11,"fmt","","",4,null],[11,"clone","","",4,null],[11,"from_pub","","",4,{"inputs":[{"name":"publishpacket"}],"output":{"name":"result"}}],[11,"set_pkid","","",4,null],[11,"get_pkid","","",4,null],[11,"to_pub","","",4,null],[11,"transform","","",4,null],[11,"clone","","",1,null],[11,"default","","",1,{"inputs":[],"output":{"name":"self"}}],[11,"new","","Creates a new `MqttOptions` object which is used to set connection\noptions for new client. Below are defaults with which this object is\ncreated.",1,{"inputs":[],"output":{"name":"mqttoptions"}}],[11,"set_keep_alive","","Number of seconds after which client should ping the broker\nif there is no other data exchange",1,null],[11,"set_client_id","","Client id of the client. A random client id will be selected\nif you don&#39;t set one",1,null],[11,"set_clean_session","","`clean_session = true` instructs the broker to clean all the client\nstate when it disconnects. Note that it is broker which is discarding\nthe client state. But this client will hold its queues and attemts to\nto retransmit when reconnection happens.  (TODO: Verify this)",1,null],[11,"set_user_name","","Set `username` for broker to perform client authentication\nvia `username` and `password`",1,null],[11,"set_password","","Set `password` for broker to perform client authentication\nvis `username` and `password`",1,null],[11,"set_pub_q_len","","All the `QoS &gt; 0` publishes state will be saved to attempt\nretransmits incase ack from broker fails.",1,null],[11,"set_sub_q_len","","",1,null],[11,"set_q_timeout","","",1,null],[11,"set_reconnect","","Time interval after which client should retry for new\nconnection if there are any disconnections.\nBy default, no retry will happen",1,null],[11,"set_will","","Set will for the client so that broker can send `will_message`\non `will_topic` when this client ungracefully dies.",1,null],[11,"set_will_qos","","Set QoS for the will message",1,null],[11,"set_will_retain","","Set will retian so that future clients subscribing to will topic\nknows of client&#39;s death.",1,null],[11,"set_ca","","Set CA file for server authentication during TLS connection",1,null],[11,"set_should_verify_ca","","Set flag to determine whether or not to verify server CA during TLS\nconnection",1,null],[11,"set_client_cert","","Set client cert and key for server to do client authentication",1,null],[11,"broker","","Creates a new mqtt client with the broker address that you want\nto connect to. Along with connection details, this object holds\nall the state information of a connection.",1,null],[11,"publish","","",3,null],[11,"retained_publish","","",3,null],[11,"userdata_publish","","",3,null],[11,"retained_userdata_publish","","",3,null],[11,"subscribe","","",3,null],[11,"disconnect","","",3,null],[11,"shutdown","","",3,null],[11,"new","","",2,{"inputs":[{"name":"mqttoptions"}],"output":{"name":"self"}}],[11,"mock_start","","",2,null],[11,"start","","Connects to the broker and starts an event loop in a new thread.\nReturns &#39;Request&#39; and handles reqests from it.\nAlso handles network events, reconnections and retransmissions.",2,null],[11,"message_callback","","Set the message callback.  This is called when a message is\nreceived from the broker.",2,null],[11,"publish_callback","","Set the publish callback.  This is called when a published\nmessage has been sent to the broker successfully.",2,null],[6,"Result","","",null,null],[11,"cmp","","",0,null],[11,"eq","","",0,null],[11,"partial_cmp","","",0,null],[11,"fmt","","",0,null],[11,"clone","","",0,null]],"paths":[[4,"QoS"],[3,"MqttOptions"],[3,"MqttClient"],[3,"MqRequest"],[3,"Message"],[4,"Error"]]};
initSearch(searchIndex);
